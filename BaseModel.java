package model;

import com.jfinal.plugin.activerecord.Model;
import com.jfinal.plugin.activerecord.Record;
import com.jfinal.plugin.activerecord.Table;
import com.jfinal.plugin.activerecord.TableMapping;

import common.JSONHelper;
import common.ReturnCode;
import common.StringHelper;
import common.VariableTable;
import exception.ErrorCodedException;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.jfinal.json.FastJson;
import com.jfinal.log.JdkLog;
import com.jfinal.log.Log;
import com.jfinal.plugin.activerecord.Db;
import com.jfinal.plugin.activerecord.IBean;

/**
 * Generated by JFinal, do not modify this file.
 */


@SuppressWarnings("serial")
public abstract class BaseModel<M extends BaseModel<M>> extends Model<M> implements IBean {
	private String whereQuery = "";
	private String selectPart = "";
	
	public Map<String, Class<? extends BaseModel>> map = new HashMap<String, Class<? extends BaseModel>>();
	protected final Log logger = JdkLog.getLog("fet_connector.log");
	
	private List<String> uniqueRelationColumns = new ArrayList<String>();
	
	public BaseModel() {
		initAssociationMap();
	}
	
	public boolean update(JSONObject body) throws JSONException, ErrorCodedException {
		Iterator<?> keys = body.keys();
		Boolean needUpdate = false;
		Table table = TableMapping.me().getTable(getClass());
		while( keys.hasNext() ) {
		    String key = (String)keys.next();
		    if(!map.containsKey(key) && !key.equalsIgnoreCase("deleteAll") && !key.equalsIgnoreCase("id") && table.hasColumnLabel(key)){
		    	needUpdate = true;
		    	break;
		    }
		}
		
		if(table.hasColumnLabel("update_dt")){
			set("update_dt",currentTime());
		}
		
		if(needUpdate){
			_setAttrs(getModelAttrFromBody(body));
			if(checkUniqueRelateConflict(false)) {
				throw getRelateConflictException();
			}
			handleAssociation(body);
			return update();
		}else{
			handleAssociation(body);
			return true;
		}
	}
	
	private String currentTime(){
		SimpleDateFormat time_formatter = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss.SS");
		return time_formatter.format(System.currentTimeMillis());
	}
	
	public boolean create(JSONObject body) throws JSONException, ErrorCodedException {
		_setAttrs(getModelAttrFromBody(body));
		if(checkUniqueRelateConflict(true)) {
			throw getRelateConflictException();
		}
		
		Table table = TableMapping.me().getTable(getClass());
		
		if(table.hasColumnLabel("update_dt") && get("update_dt") == null){
			set("update_dt",currentTime());
		}
		
		if(table.hasColumnLabel("create_dt") && get("create_dt") == null){
			set("create_dt",currentTime());
		}
		
		Boolean result = save();
		handleAssociation(body);
		return result;
	}
	
	// 刪除相關的data以及本身
	public boolean deleteWithAssociation() throws ErrorCodedException {
		// TODO Auto-generated method stub
		deleteAssociation();
		if(!super.delete()){
			throw new ErrorCodedException(ReturnCode.DATA_DELETE_FAILED, "("+ get(VariableTable.ID) + " , id = " + get(VariableTable.ID) + ")");
		}
		return true;
	}
	
	// 只刪除相關的data而不刪除本身
	public void deleteAssociation() throws ErrorCodedException {
		String linkName = getLinkName();
		if( linkName == null ) {
			logger.debug(this.getClass() + " has no association");
			return;
		}
		for (String key : map.keySet()) {
			Class<? extends BaseModel> model = map.get(key);

			try {
				BaseModel baseModelInstance = model.newInstance();				
				String sql = "select * from " + key  +" where " + linkName + " = ?";
				List<BaseModel> list = baseModelInstance.find(sql,get(VariableTable.ID).toString());
				// delete associated data recursively
				for(BaseModel baseModel: list) {
					logger.info("link name=" + baseModel.getLinkName() + ",,,,, class=" + baseModel.getClass());			
					baseModel.deleteWithAssociation();
				}
			} catch (InstantiationException | IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	protected void handleAssociationToDB(Class<? extends BaseModel> obejctClass,JSONObject obj , String key) throws JSONException, ErrorCodedException {
		try {
			BaseModel baseModelClass = obejctClass.newInstance();
			if(obj.has(VariableTable.DELETE)){
				// delete
				String id = obj.optString(VariableTable.ID);
				Model instance = baseModelClass.findById(id);
				if(instance == null){
					// 沒找到該筆資料
					throw new ErrorCodedException(ReturnCode.DATA_NOT_FOUND, "("+ key + " , id = " + id + ")");
		   	 	}else {
		   	 		// 找到該筆資料
		   		    if(!instance.deleteById(id)) {
		   		    	// 刪除失敗
						throw new ErrorCodedException(ReturnCode.DATA_DELETE_FAILED, "("+ key + " , id = " + id + ")");
		   		    }
		   	 	}
			}else if(obj.has(VariableTable.ID)){
				// update
				Object id = obj.get(VariableTable.ID);
				Model instance = baseModelClass.findById(id);
				if( instance == null ) {
					 // 沒找到該筆資料
					throw new ErrorCodedException(ReturnCode.DATA_NOT_FOUND, "("+ key + " , id = " + id + ")");
			    } else {
			        if(!((BaseModel)instance).update(obj)){
			        	// 更新失敗
			        	throw new ErrorCodedException(ReturnCode.DATA_UPDATE_FAILED, "("+ key + " , id = " + id + ")");
			        }
			    }
			}else{
				obj.put(getLinkName(),get(VariableTable.ID).toString());
				// create
		    	 if(!baseModelClass.create(obj)) {
		    		 //創建失敗
		    		 throw new ErrorCodedException(ReturnCode.DATA_CREATE_FAILED, "("+ key + " , content = " + obj.toString() + ")");
		    	 }
			}
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
		
	protected void initAssociationMap(){
		
	}
	
	
	public void deleteAll(String tableName){
		String linkName = getLinkName();
		String id = get(VariableTable.ID).toString();
		Class<? extends BaseModel> model = map.get(tableName);
		try {
			BaseModel baseModelInstance = model.newInstance();
			List<? extends BaseModel> items = baseModelInstance.find("select * from " + tableName + " where " + linkName + " = ?", id);
			for(int i = 0 ; i < items.size() ; i++){
				items.get(i).deleteWithAssociation();
			}
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ErrorCodedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}				
		return;
	}
	
	public void handleAssociation(JSONObject body) throws ErrorCodedException{
		if(body.has("deleteAll")){
			Object jsonObject;
			try {
				jsonObject = body.get("deleteAll");
				if(jsonObject instanceof JSONObject){
					JSONObject obj = (JSONObject) jsonObject;
					deleteAll(obj.getString("table_name"));
				}else if(jsonObject instanceof JSONArray){
					JSONArray objArray = (JSONArray) jsonObject;
					for(int i = 0 ; i < objArray.length(); i++){
						JSONObject obj = objArray.getJSONObject(i);
						deleteAll(obj.getString("table_name"));
					}
				}
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		for (String key : map.keySet()) {
			try {
				if(body.has(key)){
					Class<? extends BaseModel> obejctClass = (Class<? extends BaseModel>) map.get(key);
					Object jsonObject = body.get(key);
					if(jsonObject instanceof JSONObject){
						JSONObject obj = (JSONObject) jsonObject;
						handleAssociationToDB(obejctClass,obj,key);
					}else if(jsonObject instanceof JSONArray){
						JSONArray objArray = (JSONArray) jsonObject;
						for(int i = 0 ; i < objArray.length(); i++){
							JSONObject obj = objArray.getJSONObject(i);
							handleAssociationToDB(obejctClass,obj,key);
						}
					}
				}
			} catch (JSONException e) {
				e.printStackTrace();
			}
		}
	}
	
	// it should be override if subclass has association
	public String getLinkName(){
		return null;
	}
	
	public void readAssociationValue(){
		String linkName = getLinkName();
		if( linkName == null ) {
			logger.debug(this.getClass() + " has no association");
			return;
		}
		for (String key : map.keySet()) {
			Class<? extends BaseModel> modelClass = (Class<? extends BaseModel>) map.get(key);
			try {
				
				BaseModel baseModelInstance = modelClass.newInstance();				
				String sql = "select * from " + key  +" where " + linkName + " = ?";
				List<BaseModel> list = baseModelInstance.find(sql, (Object)get(VariableTable.ID));
				// read associated data recursively
				for(BaseModel baseModel: list) {
					logger.info("link name=" + baseModel.getLinkName() + ",,,,, class=" + baseModel.getClass());					
					baseModel.readAssociationValue();	
				}
				put(key,list);
			} catch (InstantiationException | IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	public void putJsonObject(String name, JSONObject obj){
		try {
			put(name,JSONHelper.jsonToMap(obj));
		} catch (JSONException e) {
			
		}
	}
	
	public void setJSONAttrs(JSONObject attrs){
		try {
			_setAttrs(getModelAttrFromBody(attrs));
		} catch (JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void put(JSONObject attrs){
		Map<String, Object> map = FastJson.getJson().parse(attrs.toString(), Map.class);
		put(map);
	}
	
	private  Map<String, Object> getModelAttrFromBody(JSONObject body) throws JSONException {
		Table table = TableMapping.me().getTable(getClass());
		Map<String, Class<?>> m = table.getColumnTypeMap();
		Map<String, Object> map = new HashMap<String, Object>();
		
		for(Map.Entry<String, Class<?>> entry:m.entrySet()){    
	        logger.info(entry.getKey() + " ---> " + entry.getValue());    
	        String currentAttrName = entry.getKey();
	        if(body.has(currentAttrName))
	        {
	        	if(body.isNull(currentAttrName)){
	        		map.put(currentAttrName, null);
	        	}else {
	        		map.put(currentAttrName, body.optString(currentAttrName));
	        	} 
	        }
		}
		return map;
	}
	
	private String sqlforGetChild(String tableName){
		return "select * from " + tableName  +" where " + getLinkName() + " = " + get(VariableTable.ID).toString();
	}
	
	public Record getChild(String tableName) {
		return Db.findFirst(sqlforGetChild(tableName));
	}
	
	public <T extends BaseModel<T>>T getChild(Class<T> modelClass) {
		T result = null;
		try {
			String tableName = modelClass.newInstance().getTableName();
			result = modelClass.newInstance().findFirst(sqlforGetChild(tableName));
		} catch (InstantiationException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}
	
	public List<Record> getChilds(String tableName) {
		return Db.find(sqlforGetChild(tableName));
	}
	
	public <T extends BaseModel<T>>List<T> getChilds(Class<T> modelClass) {
		
		List<T> result = null;
		try {
			String tableName = modelClass.newInstance().getTableName();
			result = modelClass.newInstance().find(sqlforGetChild(tableName));
		} catch (InstantiationException | IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}
	
	public String getTableName() {
		Table table = TableMapping.me().getTable(getClass());
		if(table == null) {
			String[] modelNameArray = getClass().getName().split(Pattern.quote("."));
			String modelName = modelNameArray[modelNameArray.length-1];
			return StringHelper.camelToSnake(modelName) + "s";
		}
		
		return TableMapping.me().getTable(getClass()).getName();
	} 
	
	public List<M> findBy(String key, String value) {
		return find("select * from " + getTableName() + " where " + key + " = ?", value);
	}
	
	public M findFirstBy(String key, String value) {
		return findFirst("select * from " + getTableName() + " where " + key + " = ?", value);
	}
	
	public M where(String key, String condition ,String value) throws ErrorCodedException {
		return where(key,condition,value,true);
	}
	
	public M where(String key, String condition, String value, boolean withQuote) throws ErrorCodedException {
		Table table = TableMapping.me().getTable(getClass());
		if(!table.hasColumnLabel(key)) {
			throw new ErrorCodedException(ReturnCode.SQL_ERROR);
		}
		if(whereQuery.length() > 0) {
			whereQuery += " and ";
		}
		
		if(withQuote) {
			whereQuery += table.getName() + "." + key + " " + condition + " '" + value + "'";
		}else {
			whereQuery += table.getName() + "." + key + " " + condition + " " + value;
		}
		
		return (M) this;
	}
	
	public M where(String key, String value) throws ErrorCodedException{
		return where(key,"=",value);
	}
	
	public M where(String key, String... values) throws ErrorCodedException{
		String valuesString = "(";
		boolean isFirst = true;
		for(String value : values) {
			if(!isFirst) {
				valuesString += ",";
			}
			valuesString += "'" + value + "'"; 
			isFirst = false;
		}
		valuesString += ")";
		
		return where(key,"in",valuesString,false);
	}
	
	public M where(JSONObject queryStringObject) throws UnsupportedEncodingException {
		Iterator bodyIterator = queryStringObject.keys();
		try {
			while (bodyIterator.hasNext()) {
				String key = (String) bodyIterator.next();
				String valStr = "";
				JSONArray valArray = queryStringObject.getJSONArray(key);
				if(valArray.length() < 0){
					continue;
				}
				for (int i = 0; i < valArray.length(); i++) {
					valStr += valArray.get(i).toString() + ",";
				}
				String[] values = valStr.split(",");
				where(key, values);
			}
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		return (M) this;
	}
	
	public M where(String queryString) throws UnsupportedEncodingException {
		final String[] pairs = queryString.split("&");
		for (String pair : pairs) {
			final int idx = pair.indexOf("=");
			final String key = idx > 0 ? URLDecoder.decode(pair.substring(0, idx), "UTF-8") : pair;
			final String value = idx > 0 && pair.length() > idx + 1 ? URLDecoder.decode(pair.substring(idx + 1), "UTF-8") : null;
			if(value == null) {
				continue;
			}
			try {
				String[] values = value.split(","); 
				where(key,values);
			} catch (ErrorCodedException e) {
				System.out.println("doesn't have column for key " + key);
				continue;
			}
		}
		return (M) this;
	}
	
	public M select(String query) {
		selectPart = query;
		return (M) this;
	}
	
	public String gerCurrentSQL () {
		String sql = "select * from " + getTableName();
		if(selectPart.length() > 0) {
			sql = selectPart;
		}
		
		if(whereQuery.length() > 0) {
			sql += " where " + whereQuery;
		}
		return sql;
	}
	
	public void clearSQL () {
		selectPart = "";
		whereQuery = "";
	}
	
	public List<M> find() throws ErrorCodedException {
		String sql = gerCurrentSQL();
		clearSQL();
		return find(sql);
	}
	
	public M findFirst() throws ErrorCodedException {
		String sql = gerCurrentSQL() + " limit 1";
		clearSQL();
		return findFirst(sql);
	}
	
	public void setUniqueRelate(String column1, String... columns) {
		uniqueRelationColumns = new ArrayList<String>();
		uniqueRelationColumns.add(column1);
		for(String column : columns) {
			uniqueRelationColumns.add(column);
		}
	}
	
	public boolean checkUniqueRelateConflict(boolean isCreate) {
		if(uniqueRelationColumns.size() > 0) {						
			String queryString = "";
			for (String column : uniqueRelationColumns) {
				if(get(column) == null) {
					continue;
				}
				
				queryString += queryString.length() > 0 ? " and " : "";
				queryString += column + " = '" + get(column).toString() + "'";
			}
			
			String sql = "select * from " + getTableName() + " where " + queryString;
			if(!isCreate) {
				String id = get(VariableTable.ID).toString();
				sql += "and id <> " + id;
			}
			
			try {
				BaseModel<M> instance = getClass().newInstance();
				instance = instance.findFirst(sql);
				return instance != null;
			} catch (InstantiationException | IllegalAccessException e) {
				return false;
			}
		}
		return false;
	}
	
	protected ErrorCodedException getRelateConflictException() {
		return new ErrorCodedException(ReturnCode.DATA_DUPLICATE, getDuplicateDescription());
	}
	
	protected String getDuplicateDescription() {
		String relationResult = "";
		for (String errorColumn : uniqueRelationColumns) {
			relationResult += get(errorColumn) + "(" + errorColumn + "), ";
		}
		return "(" + getTableName() + ")：" + relationResult + "已存在相同資料";
	}
	
	public String getWhereQuery(){
		return " where " + this.whereQuery;
	}
}
